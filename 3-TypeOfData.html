<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>

</html>

<script>
    /*
    ES中有7种简单的数据类型(也称原始类型):Number,String,Boolean,Null,Undefined,Symbol,BigInt. Symbol(符号)是ES6新增的,BigInt是ES10新增的
    还有一种复杂的数据类型叫Object(对象),Object是一种无需名值对的集合.因为在ES中不能定义自己的数据类型,所有值都可以用上述7种数据类型之一来表示
    只有7种数据类型似乎不足以表示全部数据.但是ES得数据类型很灵活,一种数据类型可以当做多种数据类型来使用
    */
</script>
<!-- typeof 操作符 -->
<script>
    /*
    因为ES的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型
    typeof操作符就是为此而生。
    对一个值使用typeof操作符会返回以下列字符串之一：
    undefined 表示未定义
    boolean 表示布尔值
    string 表示为字符串
    number 表示为数值
    object 表示为对象（而不是函数或null）
    function 表示为函数
    symbol 表示为符号
    */

    // 下面是使用typeof操作符的例子

    let message = "some string"

    console.log(typeof message); // string
    console.log(typeof (message)); // string
    console.log(typeof 95); // number

    // 在上面这个例子中，我们把一个变量（message）和一个数值字面量传给了typeof操作符。
    // 注意因为typeof是一个操作符而不是函数，所以不需要操作（但可以使用参数

    // 注意typeof在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如调用typeof null 返回的是“object”。
    // 这是因为特殊值null被认为是一个空对象的引用
    // 注意：严格来讲,函数在ES中被认为是对象，并不代表是一种数据类型。
    // 可是函数也有自己特殊的属性。为此，就有必要通过typeof操作符来区分函数和其他对象
</script>

<!-- undefined 类型 -->
<script>
    /*
    undefined 类型只有一个值，就是特殊值undefined。
    当使用var或者let声明了变量但是没有初始化时，就相当于给变量赋予了undefined值
    */

    let viable;
    console.log(message === undefined); // true
    //    在上面这个例子中，变量viable在声明的伤害并未初始化。而在比较他和undefined的字面值时，两者时相等的。
    //    上面这个例子等同于如下实例：
    let viable = undefined
    console.log(viable === undefined);

    // 注意：一般来说，永远不用显式的给某个变量设置undefined值
    // 字面值undefined主要用于比较,而且在ESMA-262第3版之前是不存在的.增加这个特殊值的目的就是为了明确空对象指针(null)和未初始化变量的区别

    // 包含undefined值的变量跟未定义变量还是有区别的,请看下面的例子

    let viable2; // 这个变量被声明了,只是值为undefined

    console.log(viable2); // undefined
    console.log(viable0); // viable0 未声明的变量 报错

    // 对未声明的变量只能执行一个有用的操作,就是对他调用typeof
    // 其实还可以对未声明的变量调用delete,这样也不会报错,但是这个操作没什么用,而且严格模式下会抛出错误

    // 请看下方的例子,对未初始化的变量和未声明的变量使用typeof会发现返回的都是undefined

    let viable3;

    console.log(typeof viable3); // undefined
    console.log(typeof viable_1); // undefined viable_1 是没有声明的

    // 无论是声明还是未声明,typeof返回的都是字符串"undefined"值.逻辑上这是对的,虽然严格来讲这2个变量存在根本性的差异,但是他们都无法执行实际操作
    // 注意:即使未初始化的变量会被自动赋予undefined值,但是我们仍然建议在声明变量的同时进行初始化,这样档typeof返回 "undefined"时,我们就知道
    // 那是因为给定的变量尚未声明,而不是声明了但未初始化
</script>

<!-- null 类型 -->
<script>
    /*
        null类型同样只有一个值,即特殊值null.逻辑上讲,null值表示一个空对象指针,这也是给typeof穿一个null会返回"object"的原因
    */
    let hourse = null;
    console.log(typeof hourse); // "object"

    // 在定义将来要保存对象值的变量时,建议使用null来初始化,不要使用其他值.
    // 这样,只要检查这个变量的值是不是null就可以知道这个变量是否在后来被重新赋予了一个对象的引用,比如:
    if (hourse != null) {
        // hourse 是一个对象的引用
    }

    // undefined值是由null派生而来的,因此ECMA-262将他们定义为表面上相等,如下面的例子所示:
    console.log(null == undefined); // true
    // 用等于操作符(==)比较null和undefined始终返回true.但是要注意,这个操作符(==)会为了比较而转换他的操作数(进行比较的值)


    // 即使null和undefined有关系,他们的用途也是完全不同的.
    // 永远不必显式地将变量值设置为undefined。但null不是这样的。
    // 任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用null来填充该变量。
    // 这样就可以保持null是空对象指针的语义，并进一步将其与undefined区分开来。
</script>


<!-- Boolean 类型 -->
<script>
    /*
        Boolean (布尔值)类型是ES中使用最频繁的类型之一,有2个字面值:true和false.
        这2个布尔值不同于数值,因此true不等于1,false不等于0.下民事给变量赋布尔值的例子:
    */
    let found = true;
    let lost = false;


    // 虽然布尔值只有2个,但是所有的其他ES类型的值都有相应布尔值的等价形式.
    // 要将一个其他类型的值转为布尔值,可以调佣特定的Boolean()转型函数
    let msg = "Hello World"
    let msgAsBoolean = Boolean(msg)

    // 在上面这个例子中,字符串msg会被转换为布尔值并保存在变量msgAsBoolean中.
    // Boolean转型函数可以在任意类型的数据上调用,而且始终返回一个布尔值
    // 什么值能转为true或false取决于数据类型和实际的值,下面总结了不同类型与布尔值之间的转换规则

    // 数据类型 转换为true的值 转换为false的值
    // Boolean true false
    // String 非空字符串 ""（空字符串）
    // Number 非零数值（包括无穷值）0、NaN（参见后面的相关内容）
    // Object 任意对象 null
    // Undefined N/A（不存在）undefined

</script>

<!-- Number 类型 -->
<script>

    /*
        ES中最有意思的数据类型或许就是Number了.
        Number类型使用IEEE 754格式表示整数和浮点数(在某些语言中也叫双精度值)
        不同的数值类型相应的也有不同的数值字面量格式,最基本的数值字面量格式是十进制整数,直接写出来即可:
    */
    let intNum = 55; // 整数

    // 整数也可以用八进制(以8为基数)或十六进制 (以16为基数)字面量表示.
    // 对于八进制字面量,第一个特数字必须是0,然后是相应的八进制数字(数值0-7)
    // 如果字面量包含的数字超出了应该有的范围,就会忽略前缀的0,后面的数字序列会被当成十进制数,如下所示:
    // 注意: ES2015或ES6中的八进制值通过前缀0o来表示；严格模式下，前缀0会被视为语法错误，如果要表示八进制值，应该使用前缀0o
    let octalNum1 = 0o70; // 八进制的56
    let octalNum2 = 0o79; // 无效八进制 会被当成79处理
    let octalNum3 = 0o8; //无效八进制 会被当成8处理

    // 八进制字面量在严格模式下是无效的,会导致JS引擎抛出语法错误

    // 要创建十六进制字面量,必须让真正的数值前缀0x(区分大小写),然后是十六进制数字(0-9以及A-F).
    // 十六进制数字中的字母大小写均可.下面就是几个例子:
    let hexNum1 = 0xA; // 十六进制 10
    let hexNum2 = 0x1f; // 十六进制 31

    // 使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值
    // 注意：由于JS保存数值的方式，实际中可能存在正零(+0)和负零(-0).正零和负零在所有情况下都被认为是等同的,这里特地说明一下

    // 1、浮点数
    /*
        定义浮点数，数值中必须包含小数点，而且小数点后面必须至少有一个数字。
        岁让小数点前面不是必须有整数，但是推荐加上。下面是几个例子
    */
    let floatNum1 = 1.1;
    let floatNum2 = 0.1;
    let floatNum3 = .1; // 0.1  有效,但是不是推荐

    // 因为存储浮点值使用的内存空间是存储整数值的2被,所以ES总是想方设法把值转换为整数.
    // 在小数点后面没有数字的情况下,数值就会变成整数
    // 类似地，如果数值本身就是整数，只是小数点后面跟着0（如1.0），那他也会被转换为整数，如下方所示：
    let floatNum4 = 1. // 小数点后面没有数字,被当成整数1处理
    let floatNum5 = 10.0 // 小数点后面是零,被当成整数10处理

    // 对于非常大或者非常小的数值,浮点数可以使用科学记数法来表示
    // 科学记数法用于表示一个应该乘以10的给定次幂数值
    // ES中科学计数法的格式要求是一个数值（整数或者浮点数）后跟一个大写或小写的字母e，再加上一个要乘的10的多少次幂.比如:
    let floatNum6 = 3.125e7 // 等于 31250000

    // 科学计数法也可以用于表示非常小的数值,例如0.000 000 000 000 000 03.
    // 这个数值用科学记数法可以表示为3e-17.
    // 默认情况下,ES会将小数点后至少包含6个零的浮点值转换为科学记数法(例如:0.0000003 会被转换为3e-7)

    // 浮点值的精确度可高达17位小数,但是在算术计算中远不如整数精确.
    // 例如,0.1加0.2得到的不是0.3,而是0.300 000 000 000 000 04.
    // 由于这种微小的舍入错误,导致很难测试特定的浮点值.比如下面的例子
    let a = 0.1
    let b = 0.2

    if (a + b == 0.3) {
        console.log("You got 0.3");
    }

    // 这里检测2个数值之和是否等于0.3
    // 如果这2个数值分别是0.05和0.25,或者0.15和0.15,那没问题.
    // 但如果是0.1和0.2，如前所述，测试将失败。因此永远不要测试某个特定的浮点值。
    // 注意：之所以存在这种舍入错误，是因为使用了IEEE754数值，这种错误并非ES所独有。其他使用相同格式的语言也有这个问题。

    // 2、值的范围
    /*
        由于内存的限制,ES并不支持这个世界上所有的数值.
        ES可以表示最小的数值保存在Number.MIN_VALUE中,这个值在多数浏览器中是5e-324
        ES可以表示最大的数值保存在Number.MAX_VALUE中,这个值在多数浏览器中是1.7976931348623157e+308
        如果某个计算得到的数值超出了JS可以表示的范围,那么这个数值会被自动转换为Infinity(无穷)值.
        任何无法表示的负数以-Infinity(负无穷大)表示
        任何无法表示的正数以Infinity(正无穷大)表示
    */

    // 如果计算返回正Infinity或负Infinity,则该值不能再进一步用于任何计算,
    // 这是因为Infinity没有可用于计算的数值表示形式
    // 要确定一个值是不是介于JS能表示的最小值和最大值之间，可以使用isFinite()函数,如下所示
    let result = Number.MAX_VALUE + Number.MAX_VALUE;
    console.log(isFinite(result)); // false

    // 注意: 使用Number.NEGATIVE_INFINITY和Number.POSITIVE_INFINITY也可以获取正、负Infinity。
    // 没错，这两个属性包含的值分别就是-Infinity和Infinity。


     // 3、NaN

     /*
        有一个特殊的数值叫NaN，意思时“不是数值”(Not a Number),用于表示本来要返回数值的操作失败了(而不是抛出错误).
        比如,用0除以任意数值在其他语言中通常都会导致错误,从而中止代码执行.
        但是在ES中,0,+0或者-0相除会返回NaN:
     */
        console.log(0/0); // NaN
        console.log(-0/+0) // NaN
        // 如果分子是非0值,分母是有符号0或无符号0,则会返回Infinity或-Infinity
        console.log(5/0) // Infinity;
        console.log(5/-0) // -Infinity;

        // Nan有几个独特的属性.首先,任何设计NaN的操作始终返回NaN(如NaN/10),在连续多步计算时这可能是个问题.
        // 其次,NaN不等于包括NaN在内的任何值.例如,下面比较操作会返回false:
        console.log(NaN === NaN); // false

        // 为此ES提供了isNaN()函数.该函数接收一个参数,可以是任意数据类型,然后判断这个参数是否"不是数值".
        // 把一个值传给isNaN()后,该函数会尝试把它转换为数值.某些非数值的值可以直接转换成数值,如字符串"10"或布尔值.
        // 任何不能转换为数值的值，都会导致这个函数返回true，举例如下:
        console.log(isNaN(NaN));     // true 
        console.log(isNaN(10));      // false，10是数值
        console.log(isNaN("10"));    // false，可以转换为数值10 
        console.log(isNaN("blue"));  // true，不可以转换为数值
        console.log(isNaN(true));    // false，可以转换为数值1
        // 上述的例子测试了5个不同的值。
        // 首先测试的是NaN本身，显然会返回true。
        // 接着测试了数值10和字符串"10"，都返回false，因为它们的数值都是10。
        // 字符串"blue"不能转换为数值，因此函数返回true。
        // 布尔值true可以转换为数值1，因此返回false。

        // 注意: 虽然不常见,但是isNaN()可以用于测试对象.此时,首先会调用对象的valueOf()方法,然后再确定返回的值是否可以转换为数值.
        // 如果不能，在调用toString方法，并测试其返回值，这通常是ES内置函数和操作符的工作方式，后面的学习会进行讨论

        // valueOf() JavaScript调用valueOf方法将对象转换为原始值 
        // 原始值: 即一些代表原始数据类型的值，也叫基本数据类型，直接将值存在栈中
        // 原始数据类型: string number bigint boolean undefined symbol null

        // 4、数值转换

        /*
            有3个函数可以将非数值转换为数值:Number(),parseInt()和parseFloat().
            Number()是转型函数,可用于任何数据类型.后2个函数主要用于将字符串转换为数值.
            对于同样的参数,这3个函数执行的操作也不同
        */

        // Number()函数基于如下规则执行转换。
        // 布尔值，true转换为1，false转换为0。
        // 数值，直接返回。
        // null，返回0。
        // undefined，返回NaN。
        // 字符串，应用以下规则。
        //     如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。
        //     因此，Number("1")返回1，Number("123")返回123，Number("011")返回11（忽略前面的零）。
        //     如果字符串包含有效的浮点值格式如"1.1"，则会转换为相应的浮点值（同样，忽略前面的零）。
        //     如果字符串包含有效的十六进制格式如"0xf"，则会转换为与该十六进制值对应的十进制整数值。
        //     如果是空字符串（不包含字符），则返回0。
        //     如果字符串包含除上述情况之外的其他字符，则返回NaN。
        //     对象，调用valueOf()方法，并按照上述规则转换返回的值。如果转换结果是NaN，则调用toString()方法，再按照转换字符串的规则转换。

        // 从不同数据类型到数值的转换有时候会比较复杂，看一看Number()的转换规则就知道了。下面是几个具体的例子：
        let num1 = Number("Hello world!");  // NaN 
        let num2 = Number("");              // 0 
        let num3 = Number("000011");        // 11 
        let num4 = Number(true);            // 1 
        let num5 = Number("H110");            // NaN


        // 考虑到Number()转型函数转换字符串时小队复杂且有点反常规,通常在需要得到整数时可以优先使用parseInt()函数
        let num6 = parseInt("1234blue");  // 1234 
        let num7 = parseInt("");          // NaN 
        let num8 = parseInt("0xA");       // 10，解释为十六进制整数
        let num9 = parseInt(22.5);        // 22 
        let num10 = parseInt("70");        // 70，解释为十进制值
        let num11 = parseInt("0xf");       // 15，解释为十六进制整数
        let num12 = parseInt("b100");       // NaN

        // parseInt()函数也接收第二个参数,可以指定底数(进制数),我们建议在使用parseInt()函数使尽量指定底数
        let num = parseInt("0xAF", 16); // 175 
        // 事实上，如果提供了十六进制参数，那么字符串前面的"0x"可以省掉：
        let nm1 = parseInt("AF", 16);  // 175 
        let nm2 = parseInt("AF");      // NaN 这里因为没有传入第二个参数导致解析错误

        // parseFloat()函数的工作方式跟parseInt()函数类似，都是从位置0开始检测每个字符
        // 同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。
        // 这意味着第一次出现的小数点是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。因此，"22.34.5"将转换成22.34。
    
        // parseFloat()函数的与parseInt()函数不同之处在于，它始终忽略字符串开头的零,并且只解析十进制值,不能指定底数
        // 如果字符串表示整数（没有小数点或者小数点后面只有一个零），则parseFloat()返回整数。

        let um1 = parseFloat("1234blue");  // 1234，按整数解析
        let um2 = parseFloat("0xA");       // 0 
        let um3 = parseFloat("22.5");      // 22.5 
        let um4 = parseFloat("22.34.5");   // 22.34 
        let um5 = parseFloat("0908.5");    // 908.5 
        let um6 = parseFloat("3.125e7");   // 31250000
        let um7 = parseFloat("b100");   // NaN
</script>

<!-- 
    undefined是一个假值。因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多其他可能的值同样是假值。
    所以一定要明确自己想检测的就是undefined这个字面值，而不仅仅是假值。
    (S中存在很多假值，分别是false null () "" undefined NaN)
-->