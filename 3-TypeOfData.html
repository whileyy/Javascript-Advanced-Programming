<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>

</html>

<script>
    /*
    ES中有6种简单的数据类型(也称原始类型):Number,String,Boolean,Null,Undefined,Symbol,Symbol(符号)是ES6新增的
    还有一种复杂的数据类型叫Object(对象),Object是一种无需名值对的集合.因为在ES中不能定义自己的数据类型,所有值都可以用上述7种数据类型之一来表示
    只有7种数据类型似乎不足以表示全部数据.但是ES得数据类型很灵活,一种数据类型可以当做多种数据类型来使用
    */
</script>
<!-- typeof 操作符 -->
<script>
    /*
    因为ES的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型
    typeof操作符就是为此而生。
    对一个值使用typeof操作符会返回以下列字符串之一：
    undefined 表示未定义
    boolean 表示布尔值
    string 表示为字符串
    number 表示为数值
    object 表示为对象（而不是函数或null）
    function 表示为函数
    symbol 表示为符号
    */

    // 下面是使用typeof操作符的例子

    let message = "some string"

    console.log(typeof message); // string
    console.log(typeof (message)); // string
    console.log(typeof 95); // number

    // 在上面这个例子中，我们把一个变量（message）和一个数值字面量传给了typeof操作符。
    // 注意因为typeof是一个操作符而不是函数，所以不需要操作（但可以使用参数

    // 注意typeof在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如调用typeof null 返回的是“object”。
    // 这是因为特殊值null被认为是一个空对象的引用
    // 注意：严格来讲,函数在ES中被认为是对象，并不代表是一种数据类型。
    // 可是函数也有自己特殊的属性。为此，就有必要通过typeof操作符来区分函数和其他对象
</script>

<!-- undefined 类型 -->
<script>
    /*
    undefined 类型只有一个值，就是特殊值undefined。
    当使用var或者let声明了变量但是没有初始化时，就相当于给变量赋予了undefined值
    */

    let viable;
    console.log(message === undefined); // true
    //    在上面这个例子中，变量viable在声明的伤害并未初始化。而在比较他和undefined的字面值时，两者时相等的。
    //    上面这个例子等同于如下实例：
    let viable = undefined
    console.log(viable === undefined);

    // 注意：一般来说，永远不用显式的给某个变量设置undefined值
    // 字面值undefined主要用于比较,而且在ESMA-262第3版之前是不存在的.增加这个特殊值的目的就是为了明确空对象指针(null)和未初始化变量的区别

    // 包含undefined值的变量跟未定义变量还是有区别的,请看下面的例子

    let viable2; // 这个变量被声明了,只是值为undefined

    console.log(viable2); // undefined
    console.log(viable0); // viable0 未声明的变量 报错

    // 对未声明的变量只能执行一个有用的操作,就是对他调用typeof
    // 其实还可以对未声明的变量调用delete,这样也不会报错,但是这个操作没什么用,而且严格模式下会抛出错误

    // 请看下方的例子,对未初始化的变量和未声明的变量使用typeof会发现返回的都是undefined

    let viable3;

    console.log(typeof viable3); // undefined
    console.log(typeof viable_1); // undefined viable_1 是没有声明的

    // 无论是声明还是未声明,typeof返回的都是字符串"undefined"值.逻辑上这是对的,虽然严格来讲这2个变量存在根本性的差异,但是他们都无法执行实际操作
    // 注意:即使未初始化的变量会被自动赋予undefined值,但是我们仍然建议在声明变量的同时进行初始化,这样档typeof返回 "undefined"时,我们就知道
    // 那是因为给定的变量尚未声明,而不是声明了但未初始化
</script>


<script>
    /*
        null类型同样只有一个值,即特殊值null.逻辑上讲,null值表示一个空对象指针,这也是给typeof穿一个null会返回"object"的原因
    */
    let hourse = null;
    console.log(typeof hourse); // "object"

    // 在定义将来要保存对象值的变量时,建议使用null来初始化,不要使用其他值.
    // 这样,只要检查这个变量的值是不是null就可以知道这个变量是否在后来被重新赋予了一个对象的引用,比如:
    if (hourse != null){
        // hourse 是一个对象的引用
    }

    // undefined值是由null派生而来的,因此ECMA-262将他们定义为表面上相等,如下面的例子所示:
    console.log(null == undefined); // true
    // 用等于操作符(==)比较null和undefined始终返回true.但是要注意,这个操作符(==)会为了比较而转换他的操作数(进行比较的值)


    // 即使null和undefined有关系,他们的用途也是完全不同的.
    // 永远不必显式地将变量值设置为undefined。但null不是这样的。
    // 任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用null来填充该变量。
    // 这样就可以保持null是空对象指针的语义，并进一步将其与undefined区分开来。
</script>

<!-- 
    undefined是一个假值。因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多其他可能的值同样是假值。
    所以一定要明确自己想检测的就是undefined这个字面值，而不仅仅是假值。
    (S中存在很多假值，分别是false null () "" undefined NaN)
-->