<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    <script>
        /*
        ECMAScript 变量是松散类型的，意思是变量可以用于保存任何类型的数据。
        每个变量只不过是一个用于保存任意值的命名占位符。
        有 3 个关键字可以声明变量：var、const 和 let。
        其中，var 在ECMAScript 的所有版本中都可以使用，而 const 和 let 只能在 ECMAScript 6 及更晚的版本中使用。
        */
        
        // 1、var 关键字

        var message;
        // 定义变量，可以使用var操作符， var 是一个关键字，后跟变量名，即标识符。
        // 可以用message这个变量保存任意类型的值，不初始化的情况下，变量会保存一个特殊值 undefined

        var message_ = "hi"
        // 这里，message 被定义为一个保存字符串值 hi 的变量。像这样初始化变量不会将它标识为字符串类型，只是一个简单的赋值而已
        message_ = 100;
        // 不建议随意更改变变量保存值的类型
        
        // 1.1、var声明作用域
        function test(){
            var message__ = "hi"; // 局部变量 函数结束执行会会进行销毁
        }
        test()
        console.log(message__); // 出错

        function test_(){
            // 没有用操作符var进行变量定义，直接赋值的情况，message 就变成了全局变量。只要调用一次函数 test_()，就会定义这个变量，并且可以在函数外部访问到
            // 不建议的行为，严格模式下会抛出ReferenceError错误
            message___ = 100; 
        }
        test()
        console.log(message___);
        
        // 一次性定义多个变量
        var one = 1,two = 2,three = 3;

        // 1.2、var声明提升
        // 使用 var 时，下面的代码不会报错。这是因为使用这个关键字声明的变量会自动提升到函数作用域顶部
        function foo() {
            console.log(age);
            var age = 18;
        }

        foo()
        // 之所以不会报错，是因为 ECMAScript 运行时把它看成等价于如下代码：
        function foo() {
            var age; // 这就是所谓的“提升”（hoist），也就是把所有变量声明都拉到函数作用域的顶部
            console.log(age);
            age = 18;
        }

        foo()
        // 此外，反复多次使用 var 声明同一个变量也没有问题

        function foo_ (){
            var age = 18;
            var age = 19;
            var age = 20;
            console.log(age);
        }
        foo_() // age = 20


        // 2、let声明
        // let 跟 var 的作用差不多，但有着非常重要的区别。最明显的区别是，let 声明的范围是块作用域，而 var 声明的范围是函数作用域
        if (1){
            var name = "Matt"; 
            console.log(name);// Matt
        }

        console.log(name); // Matt

        if (2){
            let name_ = "jett" 
            console.log(name_);// jett
        }
        
        // name_ 变量之所以不能在 if 块外部被引用，是因为它的作用域仅限于该{}内部。
        // 块作用域是函数作用域的子集，因此适用于 var 的作用域限制同样也适用于 let
        console.log(name_);  // ReferenceError: age 没有定


        // let 无法在同一个作用域下声明同一个变量（出现冗余声明），如果出现会导致报错
        var eg;
        var eg;

        // let lg;
        let lg; // Cannot redeclare block-scoped variable 'lg' 不能重新声明块作用域变量'lg'


        // 2.1、暂时性死区
        // let 与 var 的另一个重要的区别，就是 let 声明的变量不会在作用域中被提升。
        console.log(op18_); // ReferenceError：age 没有定义
        // op18_不会被提升
        let op18_ = "op18_"
    </script>
</body>

</html>